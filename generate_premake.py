import os
import re
from typing import Dict
from builtins import filter

MAKEFILE_FILE_NAME = 'Makefile'

# Makefile variables that contain source files - conditionals from arch.mak
file_blocks = [
    ('HEADERS', None),
    ('ARCH_HEADERS', None),
    ('BUILT_HEADERS', None),
    ('OBJS', None),

    ('ARMV5TE-OBJS', 'HAVE_ARMV5TE'),
    ('ARMV6-OBJS', 'HAVE_ARMV6'),
    ('ARMV8-OBJS', 'HAVE_ARMV8'),
    ('VFP-OBJS', 'HAVE_VFP'),
    ('NEON-OBJS', 'HAVE_NEON'),

    ('MMX-OBJS', 'HAVE_MMX'),
    ('X86ASM-OBJS', 'HAVE_X86ASM'),
]


template_header = """
-----------------------------------------------------------------------
---- Automatically generated by generate_premake.py. Do not edit ! ----
-----------------------------------------------------------------------

project("{}")
  uuid("{}")
  kind("StaticLib")
  language("C")
  ffmpeg_common()

  filter("files:not wmaprodec.c")
    warnings "Off"
"""


class FileListBuilder:
    def __init__(self, architecture_name: str, filter_name: str = ""):
        self.filter_name: str = filter_name
        self.architecture_name: str = architecture_name  # -- libavutil/Makefile:
        self.files_by_block_type: Dict[str, list] = {}  # For example: OBJS: "adler32.c"

    def add_file_to_block(self, block_type: str, file_path: str):
        if not self.files_by_block_type.get(block_type):
            self.files_by_block_type[block_type] = list()

        self.files_by_block_type[block_type].append(file_path)

    def __hash__(self):
        return self.files_by_block_type.__hash__

    def __eq__(self, other):
        return self.files_by_block_type == other.files_by_block_type

    def build(self):
        output_str = '  -- {}:\n'.format(self.architecture_name)

        for block_type in self.files_by_block_type:
            output_str += '  --   {}:\n'.format(block_type)

            if self.filter_name:
                output_str += "\n  filter({{ \n    \"{}\" \n  }})\n".format(self.filter_name)

            output_str += '  files({\n'
            for file_name in self.files_by_block_type[block_type]:
                output_str += "    \"{}\",\n".format(file_name)

            output_str += '  })\n'

        return output_str


class PremakeFileBuilder:
    def __init__(self, project_name: str, uuid: str):
        self.template: str = template_header
        self.project_name: str = project_name
        self.uuid: str = uuid
        self.files: list[FileListBuilder] = []
        self.links: list = []

        self.output: str = ""

    def build(self) -> str:
        self.output = template_header.format(self.project_name, self.uuid)

        if self.links:
            links_str = "\n    ".join(f'"{link}",' for link in self.links)
            self.output += "\n  links({{ \n    {} \n  }})".format(links_str)

        self.output += '\n\n'

        for files_builder in self.files:
            self.output += files_builder.build()

        return self.output

    #def add_files(self, file_list: FileListBuilder):
    #    self.files.append(file_list)
    #    return self

    def add_link(self, link_name: str):
        self.links.append(link_name)
        return self

    def cleanup_duplicates(self):
        new_stuff = []
        for entry in self.files:
            if entry not in new_stuff:
                new_stuff.append(entry)

        self.files = new_stuff

class Config:
    def __init__(self, os_type, architecture_type, config_h, premake_filters):
        self.os_type = os_type
        self.architecture_type = architecture_type
        self.config_header_file_name = config_h
        self.premake_filters = premake_filters
        self.key_values = []


# gets the config defines from the generated header
def parse_config(file_path: str):
    config: Dict[str, str] = {}
    # platform configs mostly differ in HAVE_*, which we are not interested in
    with open(file_path, 'r') as file:
        for line in file:
            split = line.rstrip().split(' ', 2)
            if len(split) != 3 or split[0] != '#define':
                continue

            config[split[1]] = split[2].strip('"')

    return config


def parse_configs(configs):
    for config in configs:
        config.key_values = parse_config(config.config_header_file_name)


# Adapted from distutils.sysconfig.parse_makefile
# Regexes needed for parsing Makefile (and similar syntaxes,
# like old-style Setup files).
_variable_rx = re.compile(r"([a-zA-Z][a-zA-Z0-9\-_]+)\s*(\+?)=\s*(.*)")
_variable_conditional_rx = re.compile(r"([a-zA-Z][a-zA-Z0-9\-_]+)-\$\(([a-zA-Z][a-zA-Z0-9\-_]+)\)\s*(\+?)=\s*(.*)")
_findvar1_rx = re.compile(r"\$\(([A-Za-z][A-Za-z0-9\-_]*)\)")
_findvar2_rx = re.compile(r"\${([A-Za-z][A-Za-z0-9\-_]*)}")


def parse_makefile(fn, conf, g=None):
    """Parse a Makefile-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    """
    from distutils.text_file import TextFile
    fp = TextFile(fn, strip_comments=1, skip_blanks=1, join_lines=1, errors="surrogateescape")

    if g is None:
        g = {}
    done = {}
    notdone = {}

    while True:
        line = fp.readline()
        if line is None: # eof
            break
        n = cond = app = v = None
        m = _variable_rx.match(line)
        if m:
            n, app, v = m.group(1, 2, 3)
        else:
            m = _variable_conditional_rx.match(line)
            if m:
                n, cond, app, v = m.group(1, 2, 3, 4)

        if v:
            v = v.strip()

            # `$$' is a literal `$' in make
            tmpv = v.replace('$$', '')

            if cond:
                boolean = cond in conf and conf[cond]
                n += ('-yes' if boolean else '-no')

            if "$" in tmpv:
                notdone[n] = v
            else:
                v = v.replace('$$', '$')
                if app:
                    if n not in done:
                        done[n] = v
                    else:
                        done[n] += ' ' + v
                else:
                    done[n] = v

    # hacky. just assume they were all +=
    notdone_done = {}
    # do variable interpolation here
    while notdone:
        for name in list(notdone):
            value = notdone[name]
            m = _findvar1_rx.search(value) or _findvar2_rx.search(value)
            if m:
                n = m.group(1)
                found = True
                if n in done:
                    item = str(done[n])
                elif n in notdone:
                    # get it on a subsequent round
                    found = False
                elif n in os.environ:
                    # do it like make: fall back to environment
                    item = os.environ[n]

                else:
                    notdone_done[n] = item = ""
                if found:
                    after = value[m.end():]
                    value = value[:m.start()] + item + after
                    if "$" in after:
                        notdone[name] = value
                    else:
                        notdone_done[name] = value
                        del notdone[name]
            else:
                # bogus variable reference; just drop it since we can't deal
                del notdone[name]
    for k in notdone_done:
        if k in done:
            done[k] += ' ' + notdone_done[k]
        else:
            done[k] = notdone_done[k]

    fp.close()

    # strip spurious spaces
    for k, v in done.items():
        if isinstance(v, str):
            done[k] = v.strip()

    # save the results in the global dictionary
    g.update(done)
    return g


def is_header_in_fileblocks(header: str):
    for file_block in file_blocks:
        if header == file_block[0]:
            return True

    return False


def parse_makefiles_and_create_filters(configs: list[Config], lib_premake: PremakeFileBuilder):
    makefiles = {
        os.path.join(lib_premake.project_name, MAKEFILE_FILE_NAME): configs,
        # Original Makefiles are always included but since symbols are never used we can ignore them:
        os.path.join(lib_premake.project_name, 'aarch64', MAKEFILE_FILE_NAME):
            list(filter(lambda config: config.architecture_type == 'aarch64', configs)),
        os.path.join(lib_premake.project_name, 'x86', MAKEFILE_FILE_NAME):
            list(filter(lambda config: config.architecture_type == 'x86_64', configs))
    }

    # Cache tree of parsed makefile variables
    for makefile_path in makefiles:
        if not os.path.exists(makefile_path):
            continue

        for config in configs:
            current_arch_files = FileListBuilder(makefile_path, config.premake_filters)

            makefile = parse_makefile(makefile_path, config.key_values)
            for header in makefile:
                if not is_header_in_fileblocks(header):
                    continue

                filenames = ' '.join(makefile[header].split(" ")).split()

                # TODO: Somehow handle this exception better
                # We have to convert .o files to .c files
                if header == "OBJS":
                    filenames = {filename.replace('.o', '.c') for filename in filenames}

                # Sort items
                sorted(filenames)


                for file_name in filenames:
                    current_arch_files.add_file_to_block(header, file_name)

            #current_arch_files.cleanup_duplicates()
            lib_premake.files.append(current_arch_files)


def generate_premake_file(lib_premake: PremakeFileBuilder):
    premake_file_path = os.path.join(lib_premake.project_name, 'premake5.lua')

    with open(premake_file_path, 'w') as premake:
        premake.write(lib_premake.build())


if __name__ == '__main__':
    configs = [
        Config('windows', 'x86_64', 'config_windows_x86_64.h', 'platforms:Windows'),
        Config('linux', 'x86_64', 'config_linux_x86_64.h', 'platforms:Linux'),
        Config('android', 'x86_64', 'config_android_x86_64.h', 'platforms:Android-x86_64'),
        Config('android', 'aarch64', 'config_android_aarch64.h', 'platforms:Android-ARM64'),
    ]

    parse_configs(configs)

    lib_premake_to_generate = [
        #PremakeFileBuilder('libavutil', '19216035-F781-4F15-B009-213B7E3A18AC'),
        PremakeFileBuilder('libavcodec', '9DB2830C-D326-48ED-B4CC-08EA6A1B7272').add_link("libavutil"),
        #PremakeFileBuilder('libavformat', 'CF5EF84C-894E-4D89-9D12-1F5ADE8CEB9E')
    ]

    for lib_premake in lib_premake_to_generate:
        parse_makefiles_and_create_filters(configs, lib_premake)
        # TODO: get_files_from_makefile
        lib_premake.cleanup_duplicates()
        generate_premake_file(lib_premake)

